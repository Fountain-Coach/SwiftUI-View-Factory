# service/codegen.py
from app.models.layout import LayoutNode
from typing import Dict, List, Optional, Any


def generate_swift(
    layout: LayoutNode,
    style: Optional[Dict[str, Any]] = None,
    backend_hooks: bool = False,
) -> str:
    """Convert a ``LayoutNode`` tree into a SwiftUI ``View`` struct.

    The function recursively walks the ``LayoutNode`` hierarchy and
    renders SwiftUI source code.  A very small styling dictionary is
    supported to control indentation and header comments.  The ``layout``
    provided is expected to follow the ``LayoutNode`` schema as defined in
    ``api/openapi.yml``.

    Parameters
    ----------
    layout:
        Root of the layout tree to convert.

    Returns
    -------
    str
        Swift source code for a ``GeneratedView`` struct.
    """

    # Basic style configuration.  In a future version these values might be
    # provided by the API.  For now we honour the defaults from the OpenAPI
    # specification and allow overrides via the ``style`` argument.
    style = {
        "indent": 2,
        "header_comment": True,
        "font": None,
        "color": None,
        "spacing": None,
        **(style or {}),
    }

    indent_unit = " " * int(style.get("indent", 2))
    include_header = bool(style.get("header_comment", True))
    font_style = style.get("font")
    color_style = style.get("color")
    spacing = style.get("spacing")

    lines: List[str] = []

    if include_header:
        lines.append("// Generated by SwiftUI View Factory")

    lines.append("struct GeneratedView: View {")

    state_vars: List[str] = []

    def collect_state_vars(node: LayoutNode):
        if node.type == "TextField" and node.id:
            if node.id not in state_vars:
                state_vars.append(node.id)
        for child in node.children or []:
            collect_state_vars(child)
        if node.then:
            collect_state_vars(node.then)
        if getattr(node, "else_", None):
            collect_state_vars(node.else_)

    collect_state_vars(layout)

    for var in state_vars:
        lines.append(f'{indent_unit}@State private var {var}: String = ""')

    lines.append(f"{indent_unit}var body: some View {{")

    def escape(text: str) -> str:
        return text.replace('"', '\\"')

    def render(node: LayoutNode, depth: int) -> List[str]:
        space = indent_unit * depth
        t = node.type
        out: List[str] = []

        # Preserve node id in a comment when header comments are enabled
        if include_header and node.id:
            out.append(f"{space}// id: {node.id}")

        if t in {"VStack", "HStack"}:
            if spacing is not None:
                out.append(f"{space}{t}(spacing: {spacing}) {{")
            else:
                out.append(f"{space}{t} {{")
            for child in node.children or []:
                out.extend(render(child, depth + 1))
            out.append(f"{space}}}")
        elif t == "ZStack":
            out.append(f"{space}ZStack {{")
            for child in node.children or []:
                out.extend(render(child, depth + 1))
            out.append(f"{space}}}")
        elif t == "ScrollView":
            out.append(f"{space}ScrollView {{")
            for child in node.children or []:
                out.extend(render(child, depth + 1))
            out.append(f"{space}}}")
        elif t == "NavigationStack":
            out.append(f"{space}NavigationStack {{")
            for child in node.children or []:
                out.extend(render(child, depth + 1))
            out.append(f"{space}}}")
        elif t == "List":
            out.append(f"{space}List {{")
            for child in node.children or []:
                out.extend(render(child, depth + 1))
            out.append(f"{space}}}")
        elif t == "Section":
            header = f'header: Text("{escape(node.text)}")' if node.text else ""
            prefix = f"Section({header})" if header else "Section"
            out.append(f"{space}{prefix} {{")
            for child in node.children or []:
                out.extend(render(child, depth + 1))
            out.append(f"{space}}}")
        elif t == "Form":
            out.append(f"{space}Form {{")
            for child in node.children or []:
                out.extend(render(child, depth + 1))
            out.append(f"{space}}}")
        elif t == "Text":
            content = escape(node.text or "")
            line = f'{space}Text("{content}")'
            if font_style:
                line += f".font(.{font_style})"
            if node.tag == "readOnly":
                line += ".foregroundColor(.gray)"
            elif color_style:
                line += f".foregroundColor(.{color_style})"
            out.append(line)
        elif t == "Image":
            name = escape(node.text or "")
            out.append(f'{space}Image("{name}")')
        elif t == "Spacer":
            out.append(f"{space}Spacer()")
        elif t == "Button":
            label = escape(node.text or "Button")
            line = f'{space}Button("{label}") {{}}'
            if node.role == "submit":
                line += ".buttonStyle(.borderedProminent)"
            if font_style:
                line += f".font(.{font_style})"
            if color_style:
                line += f".foregroundColor(.{color_style})"
            out.append(line)
        elif t == "TextField":
            placeholder = escape(node.text or "")
            binding = node.id or "textField"
            out.append(f'{space}TextField("{placeholder}", text: ${binding})')
        elif t == "Conditional":
            cond = node.condition or "false"
            out.append(f"{space}if {cond} {{")
            if node.then:
                out.extend(render(node.then, depth + 1))
            out.append(f"{space}}} else {{")
            if getattr(node, "else_", None):
                out.extend(render(node.else_, depth + 1))
            out.append(f"{space}}}")
        else:
            # Fallback for unknown node types - emit as a call with children
            out.append(f"{space}{t} {{")
            for child in node.children or []:
                out.extend(render(child, depth + 1))
            out.append(f"{space}}}")

        return out

    lines.extend(render(layout, 2))

    if backend_hooks:
        lines.append(f"{indent_unit*2}.onAppear {{")
        lines.append(f"{indent_unit*3}print(\"Analytics event\")")
        lines.append(f"{indent_unit*2}}}")

    lines.append(f"{indent_unit}}}")
    lines.append("}")

    return "\n".join(lines)
