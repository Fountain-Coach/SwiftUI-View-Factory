# service/codegen.py
from app.models.layout import LayoutNode
from typing import Dict, List, Optional


def generate_swift(layout: LayoutNode) -> str:
    """Convert a ``LayoutNode`` tree into a SwiftUI ``View`` struct.

    The function recursively walks the ``LayoutNode`` hierarchy and
    renders SwiftUI source code.  A very small styling dictionary is
    supported to control indentation and header comments.  The ``layout``
    provided is expected to follow the ``LayoutNode`` schema as defined in
    ``api/openapi.yml``.

    Parameters
    ----------
    layout:
        Root of the layout tree to convert.

    Returns
    -------
    str
        Swift source code for a ``GeneratedView`` struct.
    """

    # Basic style configuration.  In a future version these values might be
    # provided by the API.  For now we honour the defaults from the OpenAPI
    # specification.
    style: Dict[str, Optional[int | bool]] = {
        "indent": 2,
        "header_comment": True,
    }

    indent_unit = " " * int(style.get("indent", 2))
    include_header = bool(style.get("header_comment", True))

    lines: List[str] = []

    if include_header:
        lines.append("// Generated by SwiftUI View Factory")

    lines.append("struct GeneratedView: View {")
    lines.append(f"{indent_unit}var body: some View {{")

    def escape(text: str) -> str:
        return text.replace("\"", "\\\"")

    def render(node: LayoutNode, depth: int) -> List[str]:
        space = indent_unit * depth
        t = node.type
        out: List[str] = []

        # Preserve node id in a comment when header comments are enabled
        if include_header and node.id:
            out.append(f"{space}// id: {node.id}")

        if t in {"VStack", "HStack", "ZStack"}:
            out.append(f"{space}{t} {{")
            for child in node.children or []:
                out.extend(render(child, depth + 1))
            out.append(f"{space}}}")
        elif t == "ScrollView":
            out.append(f"{space}ScrollView {{")
            for child in node.children or []:
                out.extend(render(child, depth + 1))
            out.append(f"{space}}}")
        elif t == "Text":
            content = escape(node.text or "")
            line = f'{space}Text("{content}")'
            if node.tag == "readOnly":
                line += ".foregroundColor(.gray)"
            out.append(line)
        elif t == "Image":
            name = escape(node.text or "")
            out.append(f'{space}Image("{name}")')
        elif t == "Spacer":
            out.append(f"{space}Spacer()")
        elif t == "Button":
            label = escape(node.text or "Button")
            line = f'{space}Button("{label}") {{}}'
            if node.role == "submit":
                line += ".buttonStyle(.borderedProminent)"
            out.append(line)
        elif t == "Conditional":
            cond = node.condition or "false"
            out.append(f"{space}if {cond} {{")
            if node.then:
                out.extend(render(node.then, depth + 1))
            out.append(f"{space}}} else {{")
            if getattr(node, 'else_', None):
                out.extend(render(node.else_, depth + 1))
            out.append(f"{space}}}")
        else:
            # Fallback for unknown node types - emit as a call with children
            out.append(f"{space}{t} {{")
            for child in node.children or []:
                out.extend(render(child, depth + 1))
            out.append(f"{space}}}")

        return out

    lines.extend(render(layout, 2))

    lines.append(f"{indent_unit}}}")
    lines.append("}")

    return "\n".join(lines)
